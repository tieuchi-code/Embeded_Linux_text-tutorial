When we want to run any C program, we have to compile it from file.c to file.o

Ex: gcc -c main.c -o main.o
	-c: compile, not link (recommend in large project)
	-o: output

In case we need to compile many file, and need it to be automatically, we need makefile

Makefile structure
first, create Makefile (must be exactly name "Makefile") in the project

<variable> = <....>
<target>: <dependencies>
	<command>
---------------------------------------------------------
Ex: We have hi.c hello.c and we need to compile and link this 2 files to program.exe

cd project
vim Makefile

CC=gcc
program: hi.c hello.c
	gcc -c main.c -o main.o
	$(CC) -c hello.c -o hello.o
	gcc hi.o hello.o -o program
	($(CC) *.o -o program) -> link all file.o
	
(CC or gcc is ok, but $(CC) is more convenient, you can change CC = another compiler )
-----------------------------------------------------------

make        # build file program
./program   # run
----------------------------------------------------------

CC=gcc
program: hi.c hello.c
	gcc -c hi.c -o main.o
	$(CC) -c hello.c -o hello.o
	gcc hi.o hello.o -o program
	($(CC) *.o -o program) -> link all file.o
	
we can run this Makefile, but every time we make again, it will compile all file again 

tieuchi@tieuchi:~$ make
gcc -c hi.c -o hi.o
gcc -c hello.c -o hello.o
gcc *.o -o program

In a large project with thousands of program, compiler all again if we only change very small file is wasting
-> we need another solution

<target>: <dependencies>

program: hi.o hello.o
	gcc *.o -o program
	
hi.o: hi.c
	gcc -c hi.c -o hi.o
	
hello.o: hello.c
	gcc -c hello.c -o hello.o
------------------------------------------------------------------

To clean all file.o or file target, add this

clean:
	rm -f *.o <target>

(-f: force, not ask)
----------------------------------------------------------------

$@ :name of target
$^ :name of dependencies

Ex: 
program: hi.o hello.o
	gcc *.o -o program
->program: hi.o hello.o
	$(CC) -c $^ -o $@
---------------------------------------------------------------

SRCS = $(wildcard *.c)
-> variable SRCS will expand to all file.c

Ex: hi.c hello.c
SRCS = $(wildcard *.c)
-> SRCS= hi.c hello.c
--------------------------------------------------------------

OBJS = $(SRCS:.c=.o)
change all file.c in SRCS to file.o in OBJS

Ex: we have hi.c hello.c
SCRS= $(wildcard *.c) -> SRCS=hi.c hello.c
OBJS = $(SRCS:.c=.o)
->OBJS= hi.o hello.o
---------------------------------------------------------------

$(info ...)
->print log
---------------------------------

% :pattern- compile file with same name

Ex: hi.c -> hi.o
	hello.c -> hello.o

%.o : %.c
---------------------------------
CC=gcc
TARGET=calculate
SRCS = $(wildcard *.c)
OBJS = $(SRCS:.c=.o)

$(TARGET): $(OBJS)
        $(CC) $^ -o $@

%.o: %.c
        $(CC) -c $^ -o $@ 
debug:
        $(info all source: $(SRCS))
        $(info all objects: $(OBJS))
        $(info target: $(TARGET))       
clean:
        rm -f *.o $(TARGET) 
---------------------------------------------------------------------
$^ :all dependence
$< :only first dependence
------------------------------------------------

until now, we can compile all file.c -> file.o
But we still have file.h in project

we have command to compile file that depence to file.c
Ex: gcc -c main.c -o main.o -MMD

->main.d

DEP = -MMD

-include *.d
----------------------------------------------------
CC=gcc
TARGET=calculate
SRCS = $(wildcard *.c)
OBJS = $(SRCS:.c=.o)
DEP = -MMD
$(TARGET): $(OBJS)
        $(CC) $^ -o $@

%.o: %.c
        $(CC) -c $(DEP) $< -o $@ 
debug:
        $(info all source: $(SRCS))
        $(info all objects: $(OBJS))
        $(info target: $(TARGET))       
clean:
        rm -f *.o $(TARGET)

-include $(DEP)
































